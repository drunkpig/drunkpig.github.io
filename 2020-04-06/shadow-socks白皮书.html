<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>shadow-socks白皮书</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/code_hilighting.css" type="text/css" media="screen"
          charset="utf-8">
    <link rel="stylesheet" href="../css/simple.css" type="text/css" media="screen" charset="utf-8">
    <link rel="stylesheet" href="../css/pages.css" type="text/css" media="screen" charset="utf-8">
    <link rel="stylesheet" href="../css/mytheme.css" type="text/css" media="screen" charset="utf-8">

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$']]
            }
        };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?ccd0a4c5305cc998d59f5c06a24a2b93";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


</head>
<body>


<div class="container">
    <div class="row">
        <div class="col-lg-12">
            <h1 class="article_title">shadow-socks白皮书</h1>
            <div class="tags_container">
                
            </div>
        </div>


    </div>
    <div class="row">
        <div class="post_content col-lg-10 col-md-10 col-xs-10 col-md-10">
            <div class="toc">
<ul>
<li><a href="#shadowsocks-socks5">Shadowsocks:  一个安全socks5代理</a><ul>
<li><a href="#1">1 概述</a><ul>
<li><a href="#11">1.1 地址</a></li>
<li><a href="#12-tcp">1.2 TCP</a></li>
<li><a href="#13-udp">1.3 UDP</a></li>
</ul>
</li>
<li><a href="#2">2 数据流加密</a><ul>
<li><a href="#21">2.1 数据流加解密</a></li>
<li><a href="#22-tcp">2.2 TCP</a></li>
<li><a href="#23-udp">2.3 UDP</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h1 id="shadowsocks-socks5">Shadowsocks:  一个安全socks5代理</h1>
<p><center>S.D.T</center>
<center>January 4, 2019</center></p>
<h2 id="1">1 概述</h2>
<p>Shadowsocks (后面简称ss)是一个基于<a href="https://tools.ietf.org/html/rfc1928">SOCKS5</a>的安全代理。</p>
<p><code>客户端 &lt;---&gt; ss-client &lt;--[加密传输]--&gt; SS-server &lt;---&gt; 受限主机</code></p>
<p>ss-client 扮演了传统上的SOCKS5代理服务的功能，ss-client加密并转发客户端的数据到ss-server，ss-server将会解密并转发数据到远端受限的主机。受限主机的响应将会被ss-server加密并转发给ss-client， 最后客户端解密并发送数据到发起请求的客户端。</p>
<h3 id="11">1.1 地址</h3>
<p>代表ss服务的地址和SOCKS5的地址格式保持一致：</p>
<p><code>[1-byte type][variable-length host][2-byte port]</code></p>
<p>有三种类型的地址类型被定义：</p>
<ol>
<li>0x01: host是一个4-byte的IPV4地址。</li>
<li>0x03： host是一个变长字符串。第一个byte是一个变长字符串长度， 接下来是一个最长255-byte的域名。</li>
<li>0x04: host是一个IPV6地址</li>
</ol>
<p>最后的2-byte port是一个大端模式的无符号整形（big-endian unsigned integer)。</p>
<h3 id="12-tcp">1.2 TCP</h3>
<p>ss-client初始化一个TCP连接到ss-server, 然后ss-client发送加密的数据流到ss-server, 数据流格式如下：</p>
<p><code>[target address][payload]</code></p>
<p>以上内容会被客户端加密，加密由ss-server和ss-client配置的加密算法决定(双方算法必须保持一致）。</p>
<p>ss-server收到ss-client发送过来的加密数据，解密之后解析其中的目标地址，并与之简历一个新的TCP连接并转发payload到目标地址。ss-server随后会收到目标地址发送的响应，ss-server把响应内容加密并回传给ss-client，这个过程一致重复直到ss-client关闭连接。</p>
<h3 id="13-udp">1.3 UDP</h3>
<h2 id="2">2 数据流加密</h2>
<p>数据流加密算法只提供数据保密性，而数据的完整性和正确性并不能保证。用户尽可能使用AEAD算法。</p>
<p>下面的算法提供了合理的保密性。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>Key Size</th>
<th>IV Length</th>
</tr>
</thead>
<tbody>
<tr>
<td>aes-128-ctr</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>aes-192-ctr</td>
<td>24</td>
<td>16</td>
</tr>
<tr>
<td>aes-256-ctr</td>
<td>32</td>
<td>16</td>
</tr>
<tr>
<td>aes-128-cfb</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>aes-192-cfb</td>
<td>24</td>
<td>16</td>
</tr>
<tr>
<td>aes-256-cfb</td>
<td>32</td>
<td>16</td>
</tr>
<tr>
<td>camellia-128-cfb</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>camellia-192-cfb</td>
<td>24</td>
<td>16</td>
</tr>
<tr>
<td>camellia-256-cfb</td>
<td>32</td>
<td>16</td>
</tr>
<tr>
<td>chacha20-ietf</td>
<td>32</td>
<td>12</td>
</tr>
</tbody>
</table>
<h3 id="21">2.1 数据流加解密</h3>
<p>stream_encrypt是一个这样的加密函数：它接收一个密钥(secret key)，一个初始向量(init vector)，一条数据(message)， 函数输出一条与数据想通长度的密文(ciphertext)，过程表示如下：</p>
<p><code>stream_encrypt(secret_key, IV, message)  =&gt; ciphertext</code></p>
<p>stream_decrypt是一个解密函数，它还原原始的数据（original message)，过程如下：</p>
<p><code>stream_decrypt(secret_key, IV, ciphertext) =&gt; message</code></p>
<p>secret key可以是用户指定，也可以从一个（用户的）密码生成。secret key的生成遵从 OpenSSl里的 EVP_bytesToKey，详情可以参考 https://wiki.openssl.org/index.php/Manual:EVP_BytesToKey(3)</p>
<h3 id="22-tcp">2.2 TCP</h3>
<h3 id="23-udp">2.3 UDP</h3>

        </div>
        <div class="mytoc col-lg-2 col-md-2 col-xs-2 col-md-2">
            <span class="toc_title">目录</span>
            <div class="toc">
<ul>
<li><a href="#shadowsocks-socks5">Shadowsocks:  一个安全socks5代理</a><ul>
<li><a href="#1">1 概述</a><ul>
<li><a href="#11">1.1 地址</a></li>
<li><a href="#12-tcp">1.2 TCP</a></li>
<li><a href="#13-udp">1.3 UDP</a></li>
</ul>
</li>
<li><a href="#2">2 数据流加密</a><ul>
<li><a href="#21">2.1 数据流加解密</a></li>
<li><a href="#22-tcp">2.2 TCP</a></li>
<li><a href="#23-udp">2.3 UDP</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

        </div>
    </div>
</div>





<div class="container">
    <div class="row text-center">
	build:&nbsp;&nbsp; <a target='_blank' href='https://travis-ci.org/jscrapy/jscrapy.github.io'>__BUILD_VERSION__</a>
	
	</div>
</div>

</body>
</html>